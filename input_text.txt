Материал из Википедии — свободной энциклопедии
Перейти к навигацииПерейти к поиску
У этого термина существуют и другие значения, см. Python (значения).
Python
Python logo and wordmark.svg
Класс языка	объектно-ориентированный язык программирования
Появился в	20 февраля 1991[3]
Автор	Гвидо ван Россум[1]
Разработчик	Python Software Foundation и Гвидо ван Россум[1]
Расширение файлов	.py, .pyc, .pyd[4], .pyo, .pyw или .pyz
Выпуск
3.8.5 (21 июля 2020)[2]
Испытал влияние	Алгол 68[5], ABC[6], Модула-3[7], Си[8], C++[7], Perl, Java, Лисп, Haskell[9], APL, Клу, Dylan, Icon и SML
Лицензия	Python Software Foundation License[1]
Сайт	python.org​ (англ.)
ОС	кроссплатформенность[10]
Commons-logo.svg Медиафайлы на Викискладе
Python[комм 1] (МФА: [ˈpʌɪθ(ə)n]; в русском языке распространено название пито́н[11]) — высокоуровневый язык программирования общего назначения, ориентированный на повышение производительности разработчика и читаемости кода. Синтаксис ядра Python минималистичен. В то же время стандартная библиотека включает большой набор полезных функций.

Python поддерживает структурное, обобщенное, объектно-ориентированное, функциональное и аспектно-ориентированное программирование. Основные архитектурные черты — динамическая типизация, автоматическое управление памятью, полная интроспекция, механизм обработки исключений, поддержка многопоточных вычислений, высокоуровневые структуры данных. Поддерживается разбиение программ на модули, которые, в свою очередь, могут объединяться в пакеты.

Эталонной реализацией Python является интерпретатор CPython, поддерживающий большинство активно используемых платформ[12]. Он распространяется под свободной лицензией Python Software Foundation License, позволяющей использовать его без ограничений в любых приложениях, включая проприетарные[13]. Есть реализация интерпретатора для JVM с возможностью компиляции, CLR, LLVM, другие независимые реализации. Проект PyPy использует JIT-компиляцию, которая значительно увеличивает скорость выполнения Python-программ.

Python — активно развивающийся язык программирования, новые версии с добавлением/изменением языковых свойств выходят примерно раз в два с половиной года. Язык не подвергался официальной стандартизации, роль стандарта де-факто выполняет CPython, разрабатываемый под контролем автора языка. В настоящий момент Python занимает третье место в рейтинге TIOBE с показателем 10,2 %[14]. Аналитики отмечают, что это самый высокий балл Python за все время его присутствия в рейтинге.


Содержание
1	Философия
2	Название языка
3	История
4	Портируемость
5	Типы и структуры данных
6	Синтаксис и семантика
6.1	Операторы
6.2	Выражения
6.3	Имена
6.4	Строки документации
6.5	Директивы
7	Возможности
7.1	Объектно-ориентированное программирование
7.2	Обобщенное программирование
7.3	Функциональное программирование
7.4	Модули и пакеты
7.5	Интроспекция
7.6	Обработка исключений
7.7	Итераторы
7.8	Генераторы
7.9	Управление контекстом выполнения
7.10	Декораторы
7.11	Регулярные выражения
7.12	Другие возможности
8	Библиотеки
8.1	Стандартная библиотека
8.2	Модули расширения и программные интерфейсы
8.3	Графические библиотеки
8.4	Контроль типов и перегрузка функций
9	Примеры программ
10	Профилирование и оптимизация кода
11	Сравнение с другими языками
12	Недостатки
12.1	Синтаксис и семантика
12.2	Низкое быстродействие
12.3	Невозможность модификации встроенных классов
12.4	Глобальная блокировка интерпретатора (GIL)
13	Реализации
14	Дальнейшая разработка
14.1	График и совместимость
14.2	Возможности
15	Специализированные подмножества/расширения Python
16	Инструменты поддержки программирования
16.1	Интерактивный режим
16.2	IDE
17	Применение
18	См. также
19	Примечания
19.1	Комментарии
19.2	Источники
20	Литература
21	Ссылки
Философия
Разработчики языка Python придерживаются определённой философии программирования, называемой «The Zen of Python» («Дзен Пито́на», или «Дзен Па́йтона»)[15]. Её текст выдаётся интерпретатором Python по команде import this (работает один раз за сессию). Автором этой философии считается Тим Петерс (Tim Peters).

Текст философии:
Красивое лучше, чем уродливое.
Явное лучше, чем неявное.
Простое лучше, чем сложное.
Сложное лучше, чем запутанное.
Плоское лучше, чем вложенное.
Разреженное лучше, чем плотное.
Читаемость имеет значение.
Особые случаи не настолько особые, чтобы нарушать правила.
При этом практичность важнее безупречности.
Ошибки никогда не должны замалчиваться.
Если не замалчиваются явно.
Встретив двусмысленность, отбрось искушение угадать.
Должен существовать один — и, желательно, только один — очевидный способ сделать это.
Хотя он поначалу может быть и не очевиден, если вы не голландец[комм 2].
Сейчас лучше, чем никогда.
Хотя никогда зачастую лучше, чем прямо сейчас.
Если реализацию сложно объяснить — идея плоха.
Если реализацию легко объяснить — идея, возможно, хороша.
Пространства имён — отличная вещь! Давайте будем делать их больше!
Оригинальный текст (англ.)[показать]
Название языка

.py
Название языка произошло вовсе не от названия семейства пресмыкающихся. Автор назвал язык в честь популярного британского комедийного телешоу 1970-х «Летающий цирк Монти Пайтона». Впрочем, всё равно название языка чаще связывают именно со змеёй, нежели с передачей — пиктограммы файлов в KDE или в Microsoft Windows и даже эмблема на сайте python.org (до выхода версии 2.5) изображают змеиные головы. Важная цель разработчиков Python — создавать его забавным для использования. Это отражено в его названии, которое пришло из Монти Пайтона[16]. Также это отражено в иногда игривом подходе к обучающим программам и справочным материалам, таким как примеры использования, которые используют понятия ветчины (spam[комм 3]) и яиц[комм 4] вместо стандартных foo и bar.[17][18]

История
Основная статья: История языка программирования Python

Гвидо Ван Россум
Разработка языка Python была начата в конце 1980-х годов[19] сотрудником голландского института CWI Гвидо ван Россумом. Для распределённой ОС Amoeba требовался расширяемый скриптовый язык, и Гвидо начал писать Python на досуге, позаимствовав некоторые наработки для языка ABC (Гвидо участвовал в разработке этого языка, ориентированного на обучение программированию). В феврале 1991 года Гвидо опубликовал исходный текст в группе новостей alt.sources[20]. С самого начала Python проектировался как объектно-ориентированный язык.

Наличие дружелюбного, отзывчивого сообщества пользователей считается, наряду с дизайнерской интуицией Гвидо, одним из факторов успеха Python. Развитие языка происходит согласно чётко регламентированному процессу создания, обсуждения, отбора и реализации документов PEP (англ. Python Enhancement Proposal) — предложений по развитию Python[21].

3 декабря 2008 года[22], после длительного тестирования, вышла первая версия Python 3000 (или Python 3.0, также используется сокращение Py3k). В Python 3000 устранены многие недостатки архитектуры с максимально возможным (но не полным) сохранением совместимости со старыми версиями Python. На сегодня поддерживается одна ветка развития (Python 3.x), поддержка ветки Python 2.x закончилась в апреле 2020 года.

Портируемость
Python портирован и работает почти на всех известных платформах — от КПК до мейнфреймов. Существуют порты под Microsoft Windows, практически все варианты UNIX (включая FreeBSD и Linux), Plan 9, Mac OS и macOS, iPhone OS (iOS) 2.0 и выше, iPadOS, Palm OS, OS/2, Amiga, HaikuOS, AS/400 и даже OS/390, Windows Mobile, Symbian и Android[23].

По мере устаревания платформы её поддержка в основной ветви языка прекращается. Например, с версии 2.6 прекращена поддержка Windows 95, Windows 98 и Windows ME[24]. В версии 3.5 перестала поддерживаться Windows XP, а минимальным требованием является Windows Vista[25]. Однако на устаревших платформах можно использовать предыдущие версии Python — на данный момент сообщество активно поддерживает версии Python начиная от 2.3 (для них выходят исправления).

При этом, в отличие от многих портируемых систем, для всех основных платформ Python имеет поддержку характерных для данной платформы технологий (например, Microsoft COM/DCOM). Более того, существует специальная версия Python для виртуальной машины Java — Jython, что позволяет интерпретатору выполняться на любой системе, поддерживающей Java, при этом классы Java могут непосредственно использоваться из Python и даже быть написанными на Python. Также несколько проектов обеспечивают интеграцию с платформой Microsoft.NET, основные из которых — IronPython и Python.Net.

Типы и структуры данных
Python 3. The standard type hierarchy.png
Python поддерживает динамическую типизацию, то есть тип переменной определяется только во время исполнения. Поэтому вместо «присваивания значения переменной» лучше говорить о «связывании значения с некоторым именем». В Python имеются встроенные типы: булевый, строка, Unicode-строка, целое число произвольной точности, число с плавающей запятой, комплексное число и некоторые другие. Из коллекций в Python встроены: список, кортеж (неизменяемый список), словарь, множество и другие[26]. Все значения являются объектами, в том числе функции, методы, модули, классы.

Добавить новый тип можно либо написав класс (class), либо определив новый тип в модуле расширения (например, написанном на языке C). Система классов поддерживает наследование (одиночное и множественное) и метапрограммирование. Возможно наследование от большинства встроенных типов и типов расширений.

Все объекты делятся на изменяемые и неизменяемые: списки, словари и множества являются изменяемыми, а все остальные — неизменяемыми (например, при изменении строки фактически создаётся новая, а при изменении списка — только меняются ссылки в нём). Кортеж в Python является, по сути, неизменяемым списком. Во многих случаях кортежи работают быстрее списков[27], поэтому если вы не планируете изменять последовательность, то лучше использовать именно их. Неизменяемые объекты (и все объекты в них, если это, например, кортеж) могут быть ключами словаря (должны иметь метод hash).

Синтаксис и семантика
Язык обладает чётким и последовательным синтаксисом, продуманной модульностью и масштабируемостью, благодаря чему исходный код написанных на Python программ легко читаем. При передаче аргументов в функции Python использует вызов по соиспользованию (call-by-sharing)[28].

В 2018 году Гвидо ван Россум, создатель языка, решил ради политкорректности изменить терминологию кода, заменив в нём термины master и slave на parent и child, соответственно[29].

См. также: en:Python syntax and semantics
Операторы
Набор операторов достаточно традиционен.

Условный оператор if (если). Альтернативный блок после else (иначе). Если условий и альтернатив несколько, можно использовать elif (сокр. от else if).
Операторы цикла while (пока) и for (для). Внутри цикла возможно применение break и continue для прерывания цикла и перехода сразу к следующей итерации, соответственно.
Оператор определения класса class.
Оператор определения функции, метода или генератора def. Внутри возможно применение return (возврат) для возврата из функции или метода, а в случае генератора — yield (давать).
Оператор обработки исключений try — except — else или try — finally (начиная с версии 2.5, можно использовать finally, except и else в одном блоке).
Оператор pass ничего не делает. Используется для пустых блоков кода.
Одной из интересных синтаксических особенностей языка является выделение блоков кода с помощью отступов (пробелов или табуляций), поэтому в Python отсутствуют операторные скобки begin/end, как в языке Паскаль, или фигурные скобки, как в Си. Такой «трюк» позволяет сократить количество строк и символов в программе и приучает к «хорошему» стилю программирования. С другой стороны, поведение и даже корректность программы может зависеть от начальных пробелов в тексте. Некоторым[кому?] такое поведение может показаться не интуитивным и неудобным.

Выражения
Выражение является полноправным оператором в Python. Состав, синтаксис, ассоциативность и приоритет операций достаточно привычны для языков программирования и призваны минимизировать употребление скобок.

Отдельно стоит упомянуть операцию форматирования для строк (работает по аналогии с функцией printf() из Си), которая использует тот же символ, что и взятие остатка от деления:

>>> str_var = "world"
>>> print("Hello, %s" % str_var)
Hello, world
Python имеет удобные цепочечные сравнения. Такие условия в программах — не редкость:

1 <= a < 10 and 1 <= b < 20
Кроме того, логические операции (or и and) являются ленивыми: если для вычисления значения операции достаточно первого операнда, этот операнд и является результатом, в противном случае вычисляется второй операнд логической операции. Это основывается на свойствах алгебры логики: например, если один аргумент операции «ИЛИ» (or) является истиной, то и результат этой операции всегда является истиной. В случае, если второй операнд является сложным выражением, это позволяет сократить издержки на его вычисление. Этот факт широко использовался до версии 2.5 вместо условной конструкции:

a < b and "меньше" or "больше или равно"
Встроенные типы данных, как правило, имеют особый синтаксис для своих литералов (записанных в исходном коде констант):

"строка и Юникод-строка одновременно"
'строка и Юникод-строка одновременно'
"""тоже строка и Юникод-строка одновременно"""
True or False  # булевы литералы
3.14  # число с плавающей запятой
0b1010 + 0o12 + 0xA  # числа в двоичной, восьмеричной и шестнадцатеричной системах счисления
1 + 2j  # комплексное число
[1, 2, "a"]  # список
(1, 2, "a")  # кортеж
{'a': 1, 'b': 'B'}  # словарь
{'a', 6, 8.8}  # множество
lambda x: x**2  # анонимная функция
Для списков (и других последовательностей) Python предлагает набор операций над срезами. Особенностью является индексация, которая может показаться новичку странной, но раскрывает свою согласованность по мере использования. Индексы элементов списка начинаются с нуля. Запись среза s[N:M] означает, что в срез попадают все элементы от N включительно до M не включая. В качестве иллюстрации можно посмотреть пример работы с последовательностями. При этом индекс можно не указывать. Например, запись s[:M] означает, что в срез попадают все элементы с самого начала; запись s[N:] означает, что попадают все элементы до конца среза; запись s[:] означает, что попадают все элементы с начала и до конца.

Имена
Имя (идентификатор) может начинаться с латинской буквы (в Python 3 — буквы любого алфавита в Юникоде, например кириллицы) любого регистра или подчёркивания, после чего в имени можно использовать и цифры. В качестве имени нельзя использовать ключевые слова (их список можно узнать по import keyword; print(keyword.kwlist)) и нежелательно переопределять встроенные имена. Имена, начинающиеся с символа подчёркивания, имеют специальное значение[30].

В каждой точке программы интерпретатор имеет доступ к трём пространствам имён (то есть отображениям имён в объекты): локальному, глобальному и встроенному.

Области видимости имён могут быть вложенными друг в друга (внутри определяемой функции видны имена из окружающего блока кода). На практике с областями видимости и связыванием имён связано несколько правил «хорошего тона», о которых можно подробнее узнать из документации.

Строки документации
Python предлагает механизм документирования кода pydoc. В начало каждого модуля, класса, функции вставляется строка документации — docstring (англ.). Строки документации остаются в коде на момент времени исполнения, и в язык встроен доступ к документации[31](переменная __doc__), что используется современными IDE (Интегрированная среда разработки) (например, Eclipse).

В интерактивном режиме можно получить помощь, сгенерировать гипертекстовую документацию по целому модулю или даже применить doctest (англ.) для автоматического тестирования модуля.

Директивы
Начиная с Python 2.3, для использования в тексте программы символов, не входящих в ASCII, необходимо явно указывать кодировку исходного кода в начале модуля, например:

# -*- coding: utf-8 -*-
# или
# coding: utf-8
После этого можно использовать, например, кириллицу в Unicode-литералах. Но на самом деле даже если написать:

# coding: utf
то Python «поймёт», что вы хотели сделать.

Возможности
Объектно-ориентированное программирование
Дизайн языка Python построен вокруг объектно-ориентированной модели программирования. Реализация ООП в Python является элегантной, мощной и хорошо продуманной, но вместе с тем достаточно специфической по сравнению с другими объектно-ориентированными языками.

Возможности и особенности.

Классы являются одновременно объектами со всеми ниже приведёнными возможностями.
Наследование, в том числе множественное.
Полиморфизм (все функции виртуальные), Дженерики[32].
Инкапсуляция (два уровня — общедоступные и скрытые методы и поля). Особенность — скрытые члены доступны для использования и помечены как скрытые лишь особыми именами.
Специальные методы, управляющие жизненным циклом объекта: конструкторы, деструкторы, распределители памяти.
Перегрузка операторов (всех, кроме is, '.', '=' и символьных логических).
Свойства (имитация поля с помощью функций).
Управление доступом к полям (эмуляция полей и методов, частичный доступ, и т. п.).
Методы для управления наиболее распространёнными операциями (истинностное значение, len(), глубокое копирование, сериализация, итерация по объекту, …)
Метапрограммирование (управление созданием классов, триггеры на создание классов, и др.)
Полная интроспекция.
Классовые и статические методы, классовые поля.
Классы, вложенные в функции и классы.
Обобщенное программирование
Python поддерживает парадигму обобщенного программирования, в частности:

Дженерики[33].
Функциональное программирование
Python поддерживает парадигму функционального программирования, в частности:

функция является объектом;
функции высших порядков;
рекурсия;
развитая обработка списков (списочные выражения, операции над последовательностями, итераторы);
аналог замыканий;
частичное применение функции;
возможность реализации других средств на самом языке (например, карринг).
Модули и пакеты
Программное обеспечение (приложение или библиотека) на Python оформляется в виде модулей, которые в свою очередь могут быть собраны в пакеты. Модули могут располагаться как в каталогах, так и в ZIP-архивах. Модули могут быть двух типов по своему происхождению: модули, написанные на «чистом» Python, и модули расширения (extension modules), написанные на других языках программирования. Например, в стандартной библиотеке есть «чистый» модуль pickle и его аналог на Си: cPickle. Модуль оформляется в виде отдельного файла, а пакет — в виде отдельного каталога. Подключение модуля к программе осуществляется оператором import. После импорта модуль представлен отдельным объектом, дающим доступ к пространству имён модуля. В ходе выполнения программы модуль можно перезагрузить функцией reload().

Интроспекция
Основная статья: Интроспекция в Python
Python поддерживает полную интроспекцию времени исполнения. Это означает, что для любого объекта можно получить всю информацию о его внутренней структуре.

Применение интроспекции является важной частью того, что называют pythonic style, и широко применяется в библиотеках и фреймворках Python, таких как PyRO, PLY, Cherry, Django и др., значительно экономя время использующего их программиста.


Обработка исключений
Обработка исключений поддерживается в Python посредством операторов try, except, else, finally, raise, образующих блок обработки исключения. В общем случае блок выглядит следующим образом:

try:
    # Здесь код, который может вызвать исключение
    raise Exception("message")  # Exception, это один из стандартных типов исключения (всего лишь класс),
                                # может использоваться любой другой, в том числе свой
except (Тип исключения1, Тип исключения2, …) as Переменная:
    # Код в блоке выполняется, если тип исключения совпадает с одним из типов
    # (Тип исключения1, Тип исключения2, …) или является наследником одного
    # из этих типов.
    # Полученное исключение доступно в необязательной Переменной.
except (Тип исключения3, Тип исключения4, …) as Переменная:
    # Количество блоков except не ограничено
    raise  # Сгенерировать исключение "поверх" полученного; без параметров - повторно сгенерировать полученное
except:
    # Будет выполнено при любом исключении, не обработанном типизированными блоками except
else:
    # Код блока выполняется, если не было поймано исключений.
finally:
    # Будет исполнено в любом случае, возможно после соответствующего
    # блока except или else
Совместное использование else, except и finally стало возможно только начиная с Python 2.5. Информация о текущем исключении всегда доступна через sys.exc_info(). Кроме значения исключения, Python также сохраняет состояние стека вплоть до точки возбуждения исключения — так называемый traceback.

В отличие от компилируемых языков программирования, в Python использование исключения не приводит к значительным накладным расходам (а зачастую даже позволяет ускорить исполнение программ) и очень широко используется. Исключения согласуются с философией Python (10-й пункт «дзена Python» — «Ошибки никогда не должны умалчиваться») и являются одним из средств поддержки «утиной типизации».

Иногда вместо явной обработки исключений удобнее использовать блок with (доступен, начиная с Python 2.5).

Итераторы
В программах на Python широко используются итераторы. Цикл for может работать как с последовательностью, так и с итератором. Большинство коллекций предоставляют итераторы, итераторы могут также определяться пользователем для собственных объектов. Модуль itertools стандартной библиотеки содержит средства работы с итераторами.

Генераторы
Одной из интересных возможностей языка являются генераторы — функции, сохраняющие внутреннее состояние: значения локальных переменных и текущую инструкцию (см. также: сопрограммы). Генераторы могут использоваться как итераторы для структур данных и для ленивых вычислений. См. пример: генератор чисел Фибоначчи.

При вызове генератора функция немедленно возвращает объект-итератор, который хранит текущую точку исполнения и состояние локальных переменных функции. При запросе следующего значения (посредством метода next(), неявно вызываемого в цикле for) генератор продолжает исполнение функции от предыдущей точки остановки до следующего оператора yield или return.

В Python 2.4 появились генераторные выражения — выражения, дающие в результате генератор. Генераторные выражения позволяют сэкономить память там, где иначе требовалось бы использовать список с промежуточными результатами:

>>> sum(i for i in xrange(1, 100) if i % 2 != 0)
2500
В этом примере суммируются все нечётные числа от 1 до 99.

Начиная с версии 2.5, Python поддерживает полноценные сопроцедуры: теперь в генератор можно передавать значения с помощью метода send() и возбуждать в его контексте исключения с помощью метода throw().

Также Python поддерживает вложенные генераторы. Например, для создания двумерного массива нужно разместить генератор списка, являющегося строкой, внутри генератора всех строк: [[0 for j in range(m)] for i in range(n)]

Управление контекстом выполнения
В Python 2.5 появились средства для управления контекстом выполнения блока кода — оператор with и модуль contextlib. См.: пример.

Оператор может применяться в тех случаях, когда до и после некоторых действий должны обязательно выполняться некоторые другие действия, независимо от возбуждённых в блоке исключений или операторов return: файлы должны быть закрыты, ресурсы освобождены, перенаправление стандартного ввода вывода закончено и т. п. Оператор улучшает читаемость кода, а значит, помогает предотвращать ошибки.

Декораторы
Начиная с версии 2.4, Python позволяет использовать так называемые декораторы[34][35] (не следует путать с одноимённым шаблоном проектирования) для поддержки существующей практики преобразования функций и методов в месте определения (декораторов может быть несколько). Для декораторов используется символ @ в строках, предшествующих определению функции или метода. Синтаксис декорирования является синтаксическим сахаром[36][37] для удобочитаемости: код

@staticmethod
def my_wonderful_method():
    return "Некоторый метод"
полностью эквивалентен

def my_wonderful_method():
    return "Некоторый метод"
my_wonderful_method = staticmethod(my_wonderful_method)
Сам декоратор является функцией, получающей в качестве первого аргумента декорируемую функцию. Для передачи дополнительных аргументов можно использовать синтаксис @декоратор(аргументы). Декораторы можно считать элементом аспектно-ориентированного программирования.

С версии 2.6 декораторы можно использовать с классами аналогично функциям.

Регулярные выражения
Формат регулярных выражений унаследован из Perl с некоторыми отличиями. Для их использования требуется импортировать модуль re[38], являющийся частью стандартной библиотеки.

Другие возможности
В Python есть ещё несколько возможностей, отличающих его от многих других языков высокой гибкостью и динамичностью.

Например, класс является объектом, а в операторе определения класса в списке родительских классов можно использовать выражения.

def get_class():
    return dict

class D(get_class()):
    pass

d = D()
Можно модифицировать многие объекты во время исполнения, например классы:

>>> class X(object): pass
…
>>> y = X()
>>> y.wrong_method()  # такого метода пока нет
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'X' object has no attribute 'wrong_method'
>>> X.wrong_method = lambda self : 'im here' # добавим его
>>> y.wrong_method() # так как доступ к методу приводит к поиску по __dict__ класса,
'im here' # то wrong_method становится доступным всем экземплярам
Библиотеки
Стандартная библиотека
Основная статья: Стандартная библиотека Python

Python поставляется «с батарейками в комплекте».
Богатая стандартная библиотека является одной из привлекательных сторон Python. Здесь имеются средства для работы со многими сетевыми протоколами и форматами Интернета, например, модули для написания HTTP-серверов и клиентов, для разбора и создания почтовых сообщений, для работы с XML и т. п. Набор модулей для работы с операционной системой позволяет писать кросс-платформенные приложения. Существуют модули для работы с регулярными выражениями, текстовыми кодировками, мультимедийными форматами, криптографическими протоколами, архивами, сериализации данных, поддержка юнит-тестирования и др.

Модули расширения и программные интерфейсы
Помимо стандартной библиотеки существует множество библиотек, предоставляющих интерфейс ко всем системным вызовам на разных платформах; в частности, на платформе Win32 поддерживаются все вызовы Win32 API, а также COM в объёме не меньшем, чем у Visual Basic или Delphi. Количество прикладных библиотек для Python в самых разных областях без преувеличения огромно (веб, базы данных, обработка изображений, обработка текста, численные методы, приложения операционной системы и т. д.).

Для Python принята спецификация программного интерфейса к базам данных DB-API 2 и разработаны соответствующие этой спецификации пакеты для доступа к различным СУБД: Oracle, MySQL, PostgreSQL, Sybase, Firebird (Interbase), Informix, Microsoft SQL Server и SQLite. На платформе Windows доступ к БД возможен через ADO (ADOdb). Коммерческий пакет mxODBC для доступа к СУБД через ODBC для платформ Windows и UNIX разработан eGenix[39]. Для Python написано много ORM (SQLObject, SQLAlchemy, Dejavu, Django), выполнены программные каркасы для разработки веб-приложений (Django, Pylons, Pyramid).

Библиотека NumPy для работы с многомерными массивами позволяет иногда достичь производительности научных расчётов, сравнимой со специализированными пакетами. SciPy использует NumPy и предоставляет доступ к обширному спектру математических алгоритмов (матричная алгебра — BLAS уровней 1—3, LAPACK, БПФ…). Numarray[40] специально разработан для операций с большими объёмами научных данных.

WSGI[41] — интерфейс шлюза с веб-сервером (Python Web Server Gateway Interface).

Python предоставляет простой и удобный программный интерфейс C API для написания собственных модулей на языках Си и C++. Такой инструмент как SWIG позволяет почти автоматически получать привязки для использования C/C++ библиотек в коде на Python. Возможности этого и других инструментов варьируются от автоматической генерации (C/C++/Fortran)-Python интерфейсов по специальным файлам (SWIG, pyste[42], SIP[43], pyfort[44]), до предоставления более удобных API (boost::python[45][46], CXX[47], Pyhrol[48] и др.). Инструмент стандартной библиотеки ctypes позволяет программам Python напрямую обращаться к динамическим библиотекам/DLL, написанным на Си. Существуют модули, позволяющие встраивать код на С/C++ прямо в исходные файлы Python, создавая расширения «на лету» (pyinline[49], weave[50]).

Другой подход состоит во встраивании интерпретатора Python в приложения. Python легко встраивается в программы на Java, C/C++, OCaml. Взаимодействие Python-приложений с другими системами возможно также с помощью CORBA, XML-RPC, SOAP, COM.

С помощью проекта Cython возможна трансляция программ, написанных на языках Python и Pyrex (англ.), в код на языке Си с последующей компиляцией в машинный код. Cython используется для упрощения написания Python-библиотек, при его использовании отмечается ускорение кода и уменьшение накладных расходов.

Экспериментальный проект Shedskin предполагает создание компилятора для трансформации неявно типизированных Python-программ в оптимизированный С++ код. Начиная с версии 0.22 Shedskin позволяет компилировать отдельные функции в модули расширений.

Python и подавляющее большинство библиотек к нему бесплатны и поставляются в исходных кодах. Более того, в отличие от многих открытых систем, лицензия никак не ограничивает использование Python в коммерческих разработках и не налагает никаких обязательств, кроме указания авторских прав.

Одним из каналов распространения и обновления пакетов для Python является PyPI (англ. Python Package Index).

Графические библиотеки
С Python поставляется библиотека tkinter на основе Tcl/Tk для создания кросс-платформенных программ с графическим интерфейсом.

Существуют расширения, позволяющие использовать все основные библиотеки графических интерфейсов — wxPython[51], основанное на библиотеке wxWidgets, PyGTK для GTK, PyQt и PySide для Qt и другие. Некоторые из них также предоставляют широкие возможности по работе с базами данных, графикой и сетями, используя все возможности библиотеки, на которой основаны.

Для создания игр и приложений, требующих нестандартного интерфейса, можно использовать библиотеку Pygame. Она также предоставляет обширные средства работы с мультимедиа: с её помощью можно управлять звуком и изображениями, воспроизводить видео. Предоставляемое pygame аппаратное ускорение графики OpenGL имеет более высокоуровневый интерфейс по сравнению с PyOpenGL[52], копирующей семантику С-библиотеки для OpenGL. Есть также PyOgre[53], обеспечивающая привязку к Ogre — высокоуровневой объектно-ориентированной библиотеке 3D-графики. Кроме того, существует библиотека pythonOCC[54], обеспечивающая привязку к среде 3D-моделирования и симуляции OpenCascade[55].

Для работы с растровой графикой используется библиотека Python Imaging Library.

Для работы с векторной графикой используется PyCairo.

Контроль типов и перегрузка функций
Существуют модули, позволяющие контролировать типы параметров функций на этапе исполнения, например, typecheck[56] или method signature checking decorators[57]. Необязательная декларация типов для параметров функции добавлена в Python 3, интерпретатор при этом не проверяет типы, а только добавляет соответствующую информацию к метаданным функции для последующего использования этой информации модулями расширений[58].

Перегрузка функций реализована различными сторонними библиотеками, в том числе PEAK[59][60]. Планы, которые не были приняты, по поддержке перегрузки в Python3000[61] были частично реализованы в библиотеке overloading-lib[62].

Примеры программ
В статье «Примеры программ на языке Python» собраны примеры небольших программ, демонстрирующих некоторые возможности языка Python и его стандартной библиотеки.

Профилирование и оптимизация кода
В стандартной библиотеке Python имеется профайлер (модуль profile), который можно использовать для сбора статистики о времени работы отдельных функций. Для решения вопроса о том, какой вариант кода работает быстрее, можно использовать модуль timeit. Производимые в следующей программе измерения позволяют выяснить, какой из вариантов конкатенации строк более эффективен:

from timeit import Timer

tmp = "Python 3.2.2 (default, Jun 12 2011, 15:08:59) [MSC v.1500 32 bit (Intel)] on win32."

def case1(): # А. инкрементальные конкатенации в цикле
    s = ""
    for i in range(10000):
        s += tmp

def case2(): # Б. через промежуточный список и метод join
    s = []
    for i in range(10000):
        s.append(tmp)
    s = "".join(s)

def case3(): # В. списковое выражение и метод join
    return "".join([tmp for i in range(10000)])

def case4(): # Г. генераторное выражение и метод join
    return "".join(tmp for i in range(10000))

for v in range(1,5):
    print (Timer("func()","from __main__ import case%s as func" % v).timeit(200))
Как и в любом языке программирования, в Python имеются свои приёмы оптимизации кода. Оптимизировать код можно исходя из различных (часто конкурирующих друг с другом) критериев (увеличение быстродействия, уменьшение объёма требуемой оперативной памяти, компактность исходного кода и т. д.). Чаще всего программы оптимизируют по времени исполнения.

Здесь есть несколько очевидных правил.

Не нужно оптимизировать программу, если скорость её выполнения достаточна.
Используемый алгоритм имеет определённую временную сложность, поэтому перед оптимизацией кода программы стоит сначала пересмотреть алгоритм.
Стоит использовать готовые и отлаженные функции и модули, даже если для этого нужно немного обработать данные. Например, в Python есть встроенная функция sort().
Профилирование поможет выяснить узкие места. Оптимизацию нужно начинать с них.
Python имеет следующие особенности и связанные с ними правила оптимизации.

Вызов функций является достаточно дорогостоящей операцией, поэтому внутри вложенных циклов нужно стараться избегать вызова функций или, например, переносить цикл в функции. Функция, обрабатывающая последовательность, эффективнее, чем обработка той же последовательности в цикле вызовом функции.
Старайтесь вынести из глубоко вложенного цикла всё, что можно вычислить во внешних циклах. Доступ к локальным переменным более быстрый, чем к глобальным или чем доступ к полям.
Оптимизатор psyco может помочь ускорить работу модуля программы при условии, что модуль не использует динамических свойств языка Python.
В случае, если модуль проводит массированную обработку данных и оптимизация алгоритма и кода не помогает, можно переписать критические участки, скажем, на языке Си или Pyrex.
Инструмент под названием Pychecker[63] поможет проанализировать исходный код на Python и выдать рекомендации по найденным проблемам (например, неиспользуемые имена, изменение сигнатуры метода при его перегрузке и т. п.). В ходе такого статического анализа исходного кода могут быть выявлены и ошибки. Pylint[64] призван решать близкие задачи, но имеет уклон в сторону проверки стиля кода, поиска кода с запашком[65].

Сравнение с другими языками
Появившись сравнительно поздно, Python создавался под влиянием множества языков программирования:

ABC — отступы для группировки операторов, высокоуровневые структуры данных (map)[66][67] (Python фактически создавался как попытка исправить ошибки, допущенные при проектировании ABC);
Modula-3 — пакеты, модули, использование else совместно с try и except, именованные аргументы функций (на это также повлиял Common Lisp);
С, C++ — некоторые синтаксические конструкции (как пишет сам Гвидо ван Россум — он использовал наиболее непротиворечивые конструкции из С, чтобы не вызвать неприязнь у С-программистов к Python[66]);
Smalltalk — объектно-ориентированное программирование;
Lisp, в частности, Scheme — отдельные черты функционального программирования (lambda, map, reduce, filter и другие);
Fortran — срезы массивов, комплексная арифметика;
Miranda — списочные выражения;
Java — модули logging, unittest, threading (часть возможностей оригинального модуля не реализована), xml.sax стандартной библиотеки, совместное использование finally и except при обработке исключений, использование @ для декораторов;
Icon — генераторы.
Большая часть других возможностей Python (например, байт-компиляция исходного кода) также была реализована ранее в других языках.

Наиболее часто Python сравнивают с Perl и Ruby. Эти языки также являются интерпретируемыми и обладают примерно одинаковой скоростью выполнения программ. Как и Perl, Python может успешно применяться для написания скриптов (сценариев).

Как и Ruby, Python является хорошо продуманной системой для ООП. При этом реализация ООП в Python отличается от многих других объектно-ориентированных языков. В частности:

В отличие от Ruby, Python не придерживается идеологии «всё — объект», и поддерживает встроенные примитивные типы, не входящие в иерархию классов. Такое решение упрощает и делает более технически эффективным межъязыковое взаимодействие, хотя может быть сочтено неудобным фанатами объектного подхода.
В отличие от некоторых ООЯП (Java, Object Pascal, Ruby, …) в Python нет реального общего базового класса, от которого все объекты наследуют общие методы. Хотя формально новый класс в Python наследует (прямо или косвенно) тип object, это является только синтаксическим приёмом, так как методы, которые являются общими для всех объектов — id, type, isinstance, issubclass, str, repr, getattr, … не наследуются от object, а реализованы в виде глобальных функций. Такое решение приводит к тому, что изменение поведения этих методов производится не перегрузкой, а определением специальных методов класса.
В среде коммерческих приложений скорость выполнения программ на Python часто сравнивают с Java-приложениями[68].

Недостатки
Синтаксис и семантика
Несмотря на то, что одним из заявленных принципов дизайна Python является принцип наименьшего удивления, критики отмечают целый ряд архитектурных решений, которые могут вводить в заблуждение или вызывать недоумение у программистов, привыкших к другим распространённым языкам.[69]. В их числе:

Различная семантика присваивания для значений встроенных типов и объектов: для первых копируется значение, для вторых — копируется ссылка на тот же объект.
Отличие в поведении на некоторых типах «сокращённых» операторов, таких как += и их развёрнутой записи, хотя в большинстве языков «сокращённый» вариант — это просто краткая запись полного, и семантически они абсолютно эквивалентны.
Жёсткая трактовка лексической области видимости, подобная используемой в JavaScript: даже если переменная получает значение в последней строке функции, её областью видимости является вся функция.
Путаница между полями класса и полями объекта.
Интуитивно трудно предсказуемое поведение параметров со значением-объектом по умолчанию. Если в качестве инициализатора для параметра по умолчанию указать конструктор объекта, это приведёт к созданию статического объекта, ссылка на который и будет передаваться по умолчанию в каждый вызов[70]. Это может повлечь трудно уловимые ошибки.
Низкое быстродействие
Классический Python имеет общий со многими другими интерпретируемыми языками недостаток — сравнительно невысокую скорость выполнения программ[71]. В некоторой степени ситуацию улучшает сохранение байт-кода (расширения .pyc и, до версии 3.5, .pyo), которое позволяет интерпретатору не тратить время на синтаксический разбор текста модулей при каждом запуске.

Существуют реализации языка Python, вводящие высокопроизводительные виртуальные машины (ВМ) в качестве бэк-энда компилятора. Примерами таких реализаций может служить PyPy, базирующийся на RPython; более ранней инициативой является проект Parrot. Ожидается, что использование ВМ типа LLVM приведёт к тем же результатам, что и использование аналогичных подходов для реализаций языка Java, где низкая вычислительная производительность в основном преодолена[72]. Однако нельзя забывать, что динамический характер Python делает неизбежными дополнительные накладные расходы при исполнении программ, что ограничивает производительность Python-систем независимо от применяемых технологий. Вследствие этого для написания критических участков кода используются низкоуровневые языки, интеграция с которыми обеспечивается множеством программ и библиотек (см. выше).

В самой популярной реализации языка Python интерпретатор довольно велик и более требователен к ресурсам, чем в аналогичных популярных реализациях Tcl, Forth, LISP или Lua, что ограничивает его применение во встроенных системах. Тем не менее, Python нашёл применение в КПК и некоторых моделях мобильных телефонов[73].

Невозможность модификации встроенных классов
По сравнению с Ruby и некоторыми другими языками, в Python отсутствует возможность модифицировать встроенные классы, такие, как int, str, float, list и другие, что, однако, позволяет Python потреблять меньше оперативной памяти и быстрее работать. Ещё одной причиной введения такого ограничения является необходимость согласования с модулями расширения. Многие модули (в целях оптимизации быстродействия) преобразуют Python-объекты элементарных типов к соответствующим Си-типам вместо манипуляций с ними посредством Си-API. Также это избавляет от многих потенциальных ошибок при неконтролируемом динамическом переопределении встроенных типов.

Глобальная блокировка интерпретатора (GIL)
Основная статья: Global Interpreter Lock
Интерпретатор Python в CPython, Stackless и PyPy использует потоко-небезопасные данные, во избежание разрушения которых при совместной модификации из разных потоков применяется глобальная блокировка интерпретатора — GIL (Global Interpreter Lock): в ходе исполнения кода поток интерпретатора блокирует GIL, выполняет некоторое количество инструкций (по умолчанию 100), после чего освобождает блокировку и приостанавливается, давая возможность работать другим потокам. GIL также освобождается во время ввода-вывода, изменения и проверки состояния синхронизирующих примитивов, при исполнении кода расширений, не обращающихся к данным интерпретатора, например, NumPy/SciPy. Таким образом, в каждый момент времени в одном процессе интерпретатора Python может исполняться только один поток кода на Python, независимо от числа доступных процессорных ядер.

Потери производительности от GIL зависят от характера программ и архитектуры системы. Большинство программ является однопоточными, либо запускает всего несколько потоков, из которых часть в каждый конкретный момент простаивает в ожидании. Персональные компьютеры обычно имеют небольшое количество процессорных ядер, которые загружены параллельно исполняющимися в системе процессами, так что реальные потери производительности на персональных компьютерах из-за GIL невелики. Но в серверных приложениях может быть удобно использовать десятки и сотни (а то и больше) параллельных потоков (например, в системах массового обслуживания, где каждый поток обрабатывает данные для отдельного пользовательского запроса), а серверы на конец 2010-х годов нередко имеют десятки и даже сотни процессорных ядер, то есть технически могут обеспечить этим потокам физически одновременное исполнение; в таких условиях GIL может приводить к действительно значительному снижению общей производительности, так как лишает программу возможности полноценно использовать ресурсы многоядерных систем.

Ведётся работа по оптимизации GIL[74][75]. Отказ от GIL в ближайшем будущем не планируется, так как альтернативные механизмы на однопоточных приложениях, которых большинство, работают медленнее или потребляют больше ресурсов:

Вариант интерпретатора с синхронизацией доступа к отдельным объектам вместо глобальной блокировки[76] из-за частых захватов/освобождений блокировок оказался слишком медленным.
python-safethread — CPython без GIL,[77] по утверждениям авторов, обеспечивает на однопоточных приложениях скорость порядка 60-65 % от скорости CPython.
Реализация потоков через процессы ОС, например, модуль processing[78] (с версии 2.6 переименован в multiprocessing). В UNIX-подобных системах накладные расходы при порождении процесса невелики, но в Windows использование процессов вместо потоков ведёт к существенному увеличению расхода оперативной памяти.
Отказ от совместного использования изменяемых данных и вызовов внешнего кода. При этом данные дублируются в потоках и их синхронизация (если таковая нужна) лежит на программисте[79]. Этот подход также увеличивает потребление оперативной памяти, хотя и не настолько сильно, как при использовании процессов в Windows.
Библиотеки, обеспечивающие собственную организацию поддержки потоков, такие как parallelpython[80], pympi[81] и другие.
Радикальным вариантом решения проблемы может быть переход на Jython и IronPython, работающие на виртуальных машинах Java и .NET/Мono: эти реализации вообще не используют GIL.

Реализации
CPython является основной, но не единственной реализацией языка программирования Python. Существуют также другие реализации.

PyPy — реализация Python, написанная на RPython (подмножество Python, имеющее намного меньше динамических возможностей). Позволяет легко проверять новые возможности. В PyPy, кроме стандартного CPython, включены возможности Stackless, Psyco, модификация AST «на лету» и многое другое. В проект интегрированы возможности анализа Python-кода и трансляция в другие языки и байткоды виртуальных машин (Си, LLVM, Javascript, .NET с версии 0.9.9). Начиная с 0.9.0, возможна полностью автоматическая трансляция RPython в Си, в результате чего достигается скорость, приемлемая для использования (в 2—3 раза ниже, чем CPython при отключённом JIT для версии 0.9.9). По умолчанию PyPy поставляется со встроенным JIT-компилятором, с помощью которого он способен работать намного быстрее, чем CPython.
Numba[en] — Jit-компилятор на основе LLVM с поддержкой NumPy.
PyS60[73] — реализация языка для смартфонов фирмы Nokia на платформе Series 60.
IronPython — Python для .NET Framework и Mono. Компилирует Python программы в MSIL, таким образом предоставляя полную интеграцию с .NET-системой[82].
Stackless — также написанная на Си реализация Python. Это не полноценная реализация, а патчи к CPython. Предоставляет расширенные возможности многопоточного программирования и значительно большую глубину рекурсии.
Python for .NET[83] — ещё одна реализация Python для .NET. В отличие от IronPython эта реализация не компилирует Python код в MSIL, а только предоставляет интерпретатор, написанный на C#. Позволяет использовать .NET-сборки из Python кода.
Jython — реализация Python, использующая JVM в качестве среды исполнения. Позволяет прозрачно использовать Java-библиотеки[84].
python-safethread[77] — версия CPython без GIL, что позволяет одновременно исполнять Python потоки на всех доступных процессорах. Внесены также некоторые другие изменения.
Unladen Swallow — начатый Google проект по разработке высокоэффективного, максимально совместимого с CPython JIT-компилятора на базе LLVM. Согласно планам по развитию Python[85], планировалось перенести исходный код Unladen Swallow в CPython в версии 3.3. Но PEP-3146 был отменён в связи с отсутствием интереса к Unladen Swallow со стороны Google, основного спонсора разработки[86].
tinypy[87] — минималистическая версия Python. Часть возможностей CPython не реализована.
MicroPython — реализация Python 3 для встроенных систем с малым объёмом оперативной памяти[88].
Brython[89] — реализация языка на клиентском JavaScript, позволяющая писать браузерные скрипты на Python 3.
QPython[90] — реализация python для Android. Проект всё ещё на стадии тестирования, однако на qpython уже портированы некоторые самые необходимые библиотеки. Позволяет и работать в интерактивном режиме. Существует также Qpython3.
Дальнейшая разработка
Python Enhancement Proposal («PEP») — это документ со стандартизированным дизайном, предоставляющий общую информацию о языке Python, включая новые предложения, описания и разъяснения возможностей языка. PEP предлагаются как основной источник для предложения новых возможностей и для разъяснения выбора того или иного дизайна для всех основных элементов языка. Выдающиеся PEP рецензируются и комментируются Гвидо ван Россумом, имеющим в проекте статус «великодушного пожизненного диктатора». 12 июля 2018 года Гвидо ван Россум отправил себя в бессрочный отпуск с должности «великодушного пожизненного диктатора»[91][92].

График и совместимость
Серии Python 2.x и Python 3.x в течение нескольких выпусков будут существовать параллельно, при этом серия 2.x будет использоваться для совместимости и скорее всего в неё будут включены некоторые возможности серии 3.x. PEP 3000 содержит больше информации о планируемых выпусках.

Python 3.0 обратно не совместим с предыдущей серией 2.x. Код Python 2.x часто будет выдавать ошибки при исполнении в Python 3.0. Динамическая типизация Python вместе с планами изменения нескольких методов словарей делает механический перевод из Python 2.x в Python 3.0 очень сложным. Однако утилита «2to3» уже способна сделать большинство работы по переводу кода, указывая на подозрительные его части с помощью комментариев и предупреждений. PEP 3000 рекомендует держать исходный код для серии 2.x и делать выпуски для Python 3.x с помощью «2to3». Полученный код не следует редактировать, пока программа не будет работоспособной в Python 2.x.

Возможности
Основные изменения, внесённые в версии 3.0[93][94][95][96]:

Синтаксическая возможность для аннотации параметров и результата функций (например, для передачи информации о типе или документирования).
Полный переход на unicode для строк.
Введение нового типа «неизменяемые байты» и типа «изменяемый буфер». Оба необходимы для представления бинарных данных.
Новая подсистема ввода-вывода (модуль io), имеющая отдельные представления для бинарных и текстовых данных.
Абстрактные классы, абстрактные методы (доступно уже в 2.6).
Иерархия типов для чисел.
Выражения для словарей и множеств {k: v for k, v in a_dict} и {el1, el2, el3} (по аналогии со списковыми выражениями). Эта возможность была также добавлена в Python 2.7
Изменения print из встроенного выражения во встроенную функцию. Это позволит модулям делать изменения, подстраиваясь под разное использование функции, а также упростит код. В Python 2.7 эта возможность активируется вводом from __future__ import print_function.
Перемещение reduce (но не map или filter) из встроенного пространства в модуль functools (использование reduce существенно менее читабельно по сравнению с циклом).
Удаление некоторых устаревших возможностей, поддерживаемых в ветке 2.x для совместимости, в частности: классы старого стиля, целочисленное деление с обрезанием результата как поведение по умолчанию, строковые исключения, неявный относительный импорт, оператор exec и т. п.
Реорганизация стандартной библиотеки.
Новый синтаксис для метаклассов.
Изменён синтаксис присваиваний. Стало возможным, например, присваивание a, *rest, b = range(5). С другой стороны, формальные параметры функций вроде def foo(a, (b, c)) более недопустимы.
Специализированные подмножества/расширения Python
На основе Python было создано несколько специализированных подмножеств языка, в основном предназначенных для статической компиляции в машинный код. Некоторые из них перечислены ниже.

RPython[97] — созданная в рамках проекта PyPy сильно ограниченная реализация Python без динамизма времени исполнения и некоторых других возможностей. Код на RPython можно компилировать во множество других языков/платформ — C, JavaScript, Lisp, .NET[98], LLVM. На RPython написан интерпретатор PyPy.
Pyrex[99] — ограниченная реализация Python, но несколько меньше, чем RPython. Pyrex расширен возможностями статической типизации типами из языка С и позволяет свободно смешивать типизированный и не типизированный код. Предназначен для написания модулей расширений, компилируется в код на языке С.
Cython[100] — расширенная версия Pyrex.
Проект Shedskin — предназначен для компиляции неявно статически типизированного кода на Python в оптимизированный код на языке С++.

IDLE
Инструменты поддержки программирования
Интерактивный режим
Подобно Лиспу и Прологу, Python может использоваться в интерактивном режиме, при котором введённые с клавиатуры операторы сразу же выполняются, а результат выводится на экран (REPL). Этот режим удобен как при изучении языка, так и в процессе профессиональной разработки — для быстрого тестирования отдельных фрагментов кода, — так как обеспечивает немедленную обратную связь. Также он позволяет использовать интерпретатор в качестве калькулятора с большим набором функций.

Эталонная реализация Python имеет встроенный интерактивный интерпретатор, работающий в режиме текстового терминала и позволяющий выполнять все основные операции. В интерактивном режиме доступен отладчик pdb и система помощи (вызывается по help()), работающая для всех модулей, классов и функций, которые содержат строки документации.
>>> 2 ** 100 # возведение 2 в степень 100
1267650600228229401496703205376L
>>> from math import * # импорт математических функций
>>> sin(pi * 0.5) # вычисление синуса от половины пи
1.0
>>> help(sorted) # помощь по функции sorted
Help on built-in function sorted in module __builtin__:
sorted(...)
   sorted(iterable, cmp=None, key=None, reverse=False) --> new sorted list
IPython[101] — выходящая под BSD-лицензией кросс-платформенная интерактивная оболочка, предоставляющая расширенную интроспекцию и дополнительные команды. В частности, позволяет передавать исполняемому коду на Python результаты выполнения команд системной командной оболочки. Поддерживает подсветку кода и автоматическое дополнение.
bpython[102] — расширение стандартной командной оболочки Python с помощью ряда дополнительных модулей. Реализует подсветку синтаксиса, автоматическое дополнение кода с предложением вариантов, автоматическое выравнивание, интеграция с Pastebin, сохранение ввода в файл, восстановление удалённой строки, предложение параметров для функций.
Почти все IDE для Python поддерживают REPL для быстрого тестирования.

IDE
Существует несколько специализированных IDE для разработки на Python.

Eric — полнофункциональный редактор Python и IDE, написанный на Python. Он базируется на кросс-платформенном фреймворке Qt, в качестве компонента редактирования используется QScintilla. Eric предоставляет возможности ведения проектов, отладки, профилирования, рефакторинга кода, взаимодействия с популярными системами управления версиями, такими как Subversion и Git. Расширяется через механизм плагинов. Репозиторий плагинов доступен прямо из среды разработки. Распространяется бесплатно, лицензия GNU GPL v3.
PyCharm — полнофункциональная IDE для Python от JetBrains, доступна на платформах Windows, Mac OS X и Linux, существует в бесплатном (Community) и платном (Professional) вариантах.
Wing IDE (англ.)русск. — линейка Python-IDE от американской фирмы Wingware, включает три варианта: «Wing 101», «Wing Personal», «Wing Pro», из которых первые два бесплатны, последний — платный. Версия Pro обладает всеми необходимыми средствами для профессиональной разработки, включая поддержку проектов, работу с системами управления версиями, расширенные возможности навигации по коду и анализа кода, рефакторинг, поддержка использования Django. Бесплатные версии предоставляют меньше функций и не выходят за пределы возможностей, доступных в других бесплатных IDE для Python.
Spyder — open-source IDE для Python под лицензией MIT, бесплатная, доступна на платформах Windows, Mac OS X и Linux. Особенностью является то, что IDE ориентирована на data science, в ней удобно работать с библиотеками типа SciPy, NumPy, Matplotlib. Spyder поставляется в комплекте с менеджером пакетов Anaconda. В целом обладает качествами стандартной IDE, имеет редактор с подсветкой синтаксиса, автоматическое дополнение кода, обозреватель документации.
Thonny — многоплатформенная бесплатная IDE, выпускается под лицензией MIT, поддерживается Институтом информатики Тартуского университета в Эстонии. Позиционируется как «Python IDE для новичков», полностью, включая интерпретатор Python, ставится «из коробки» пользователем без административных прав, сразу после установки может использоваться без дополнительных настроек. Предназначена для обучения, имеет улучшенную визуализацию порядка вычисления выражений и вызова функций, динамическую подсветку синтаксических ошибок, простой менеджер пакетов. Для профессионального применения возможностей недостаточно, например, нет поддержки проектов и интеграции с системами управления версиями.
Помимо этого, существуют плагины для поддержки программирования на Python для универсальных IDE Eclipse, KDevelop и Microsoft Visual Studio, а также имеется поддержка подсветки синтаксиса, автодополнения кода и подключения средств отладки и запуска приложений для целого ряда распространённых текстовых редакторов.

Применение
Python — стабильный и распространённый язык. Он используется во многих проектах и в различных качествах: как основной язык программирования или для создания расширений и интеграции приложений. На Python реализовано большое количество проектов, также он активно используется для создания прототипов будущих программ. Python используется во многих крупных компаниях[103]: Dropbox, Google (например некоторые части Youtube и Youtube API написаны на Python[104]), Facebook[105], Instagram[106].

Python с пакетами NumPy, SciPy и MatPlotLib активно используется как универсальная среда для научных расчётов в качестве замены распространённым специализированным коммерческим пакетам Matlab, IDL и другим. Библиотека Astropy — популярный инструмент для астрономических расчётов.

Сочетание простоты и лаконичности с возможностью использования сложных абстракций и мощных разнообразных инструментов делает Python удобным в качестве скриптового языка. Возможность его встраивания ограничивается объёмом интерпретатора, но в крупных системах это ограничение несущественно. В профессиональных программах трёхмерной графики, таких как Autodesk Maya, Blender, Houdini и Nuke, Python используется для расширения стандартных возможностей программ[107][108]. В Microsoft Power BI Desktop Python, наряду со встроенными языками запросов и языком программирования R, может использоваться на этапе загрузки данных в ETL-процессах, расчётах и графической визуализации данных[109][110].

Также Python подходит для выполнения нестандартных или сложных задач в системах сборки проектов, что обусловлено отсутствием необходимости предварительной компиляции исходных файлов. В проекте Google Test он используется для генерации исходного кода mock-объектов для классов языка C++[111].

Интерпретатор Python может использоваться в качестве мощной командной оболочки и скриптового языка для написания командных файлов ОС. Лёгкость обращения из Python-скриптов к внешним программам и наличие библиотек, дающих доступ к управлению системой, делают Python удобным инструментом для системного администрирования.[112] Он широко используется для этой цели на платформе Linux: обычно Python поставляется с системой, во многих дистрибутивах инсталляторы и визуальный интерфейс системных утилит написаны именно на Python. Используется он и в администрировании других Unix-систем, в частности, в Solaris и macOS.[112] Кроссплатформенность самого языка и библиотек делает его привлекательным для унифицированной автоматизации задач системного администрирования в гетерогенных средах, где совместно применяются компьютеры с операционными системами различных типов.